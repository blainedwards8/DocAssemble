import fs from 'fs';
import path from 'path';

const SCHEMA_PATH = path.resolve('pb_schema.json');
const OUTPUT_PATH = path.resolve('src/lib/types.d.ts');

const typeMap = {
    text: 'string',
    number: 'number',
    bool: 'boolean',
    email: 'string',
    url: 'string',
    date: 'string',
    select: 'string',
    json: 'any',
    file: 'string',
    relation: 'string', // Usually an ID
    user: 'string', // User ID
    autodate: 'string'
};

function generateTypes() {
    try {
        const schemaContent = fs.readFileSync(SCHEMA_PATH, 'utf8');
        const schema = JSON.parse(schemaContent);

        let subOutput = `/**
 * This file was auto-generated by scripts/generate-types.js
 * Do not modify this file directly.
 */

export interface BaseModel {
    id: string;
    created: string;
    updated: string;
    [key: string]: any;
}

export interface AuthModel extends BaseModel {
    email: string;
    emailVisibility: boolean;
    verified: boolean;
}

`;

        schema.forEach(collection => {
            const interfaceName = collection.name.charAt(0).toUpperCase() + collection.name.slice(1).replace(/_([a-z])/g, (g) => g[1].toUpperCase());

            const isAuth = collection.type === 'auth';
            const baseInterface = isAuth ? 'AuthModel' : 'BaseModel';

            let interfaceContent = `export interface ${interfaceName} extends ${baseInterface} {\n`;

            collection.fields.forEach(field => {
                if (['id', 'created', 'updated', 'collectionId', 'collectionName', 'expand'].includes(field.name)) return;
                if (isAuth && ['email', 'emailVisibility', 'verified', 'password', 'passwordConfirm', 'oldPassword'].includes(field.name)) return;

                try {
                    let tsType = typeMap[field.type] || 'any';

                    if (field.type === 'select' && Array.isArray(field.values)) {
                        tsType = field.values.map(v => `"${String(v).replace(/"/g, '\\"')}"`).join(' | ');
                        if (!tsType) tsType = 'string';
                    }

                    // Array types
                    if (field.maxSelect && field.maxSelect > 1) {
                        // For relation/file fields with multiple select
                        if (field.type === 'file' || field.type === 'relation') {
                            tsType = 'string[]'; // Force string array for IDs
                        }
                    }

                    const required = field.required ? '' : '?';
                    interfaceContent += `    ${field.name}${required}: ${tsType}; \n`;
                } catch (e) {
                    console.error('Error processing field:', field);
                    throw e;
                }
            });

            interfaceContent += `} \n\n`;
            subOutput += interfaceContent;
        });

        fs.writeFileSync(OUTPUT_PATH, subOutput);
        console.log(`Types generated at ${OUTPUT_PATH} `);

    } catch (err) {
        console.error('Error generating types:', err);
        process.exit(1);
    }
}

generateTypes();
